import pandas as pd
import numpy as np
import argparse
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
import os
import sys

def main():
    parser = argparse.ArgumentParser(description="Train a regression model to predict the number of CRISPR arrays.")
    parser.add_argument("--summary_table", required=True, help="Path to the summary table CSV generated by summarize_crisprs.py.")
    parser.add_argument("--metadata_table", required=True, help="Path to the metadata CSV file (e.g., limited.csv).")
    parser.add_argument("--model", choices=['linear', 'random_forest'], default='random_forest', help="Type of regression model to use.")
    parser.add_argument("--test_size", type=float, default=0.2, help="Proportion of the dataset to include in the test split.")
    parser.add_argument("--output_folder", default="model_output", help="Folder to save model outputs and results.")
    args = parser.parse_args()

    # Create output folder if it doesn't exist
    os.makedirs(args.output_folder, exist_ok=True)

    # Read the tables
    try:
        # Assume that summary_table.csv is semicolon-delimited and limited.csv is comma-delimited
        summary_df = pd.read_csv(args.summary_table, delimiter=';')
    except Exception as e:
        print(f"Error reading summary table: {e}")
        sys.exit(1)

    try:
        metadata_df = pd.read_csv(args.metadata_table, delimiter=',')
    except Exception as e:
        print(f"Error reading metadata table: {e}")
        sys.exit(1)

    # Inspect the first few rows to verify 'Fasta file' column exists
    if 'Fasta file' not in metadata_df.columns:
        print("Error: 'Fasta file' column not found in metadata table.")
        print("Available columns:", metadata_df.columns.tolist())
        sys.exit(1)

    # Merge the dataframes on the sample name
    # Remove any leading/trailing whitespaces in filenames
    summary_df['sample'] = summary_df['sample'].str.strip()
    metadata_df['Fasta file'] = metadata_df['Fasta file'].str.strip()

    # Replace any potential inconsistencies in file extensions
    # For example, ensure both have the same extension (.fasta)
    summary_df['sample'] = summary_df['sample'].str.replace('.fasta', '.fasta', regex=False)
    metadata_df['Fasta file'] = metadata_df['Fasta file'].str.replace('.fasta', '.fasta', regex=False)

    # Merge dataframes on the sample name
    merged_df = pd.merge(summary_df, metadata_df, left_on='sample', right_on='Fasta file', how='inner')

    if merged_df.empty:
        print("The merged dataframe is empty. Please check if the sample names match between the summary table and metadata table.")
        print("Ensure that both 'sample' in summary_table and 'Fasta file' in metadata_table have matching filenames.")
        sys.exit(1)

    # Notify about the number of merged samples
    print(f"Number of samples after merging: {len(merged_df)}")

    # Prepare the features and target
    y = merged_df['num_crispr_arrays']
    # Drop irrelevant or target columns
    X = merged_df.drop(columns=[
        'sample',
        'Fasta file',
        'num_crispr_arrays',
        'average_crispr_length',
        'average_AT',
        'percent_plus_orientation',
        'percent_minus_orientation'
    ])

    # Handle categorical variables using one-hot encoding
    categorical_cols = X.select_dtypes(include=['object']).columns
    if not categorical_cols.empty:
        X = pd.get_dummies(X, columns=categorical_cols, drop_first=True)
    
    # Check for missing values
    if X.isnull().any().any():
        print("Missing values detected in the features. Filling missing values with the mean of each column.")
        X = X.fillna(X.mean())

    # Split into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=args.test_size, random_state=42)

    # Train the model
    if args.model == 'linear':
        model = LinearRegression()
    else:
        model = RandomForestRegressor(n_estimators=100, random_state=42)

    model.fit(X_train, y_train)

    # Make predictions
    y_pred = model.predict(X_test)

    # Evaluate the model
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)

    print(f"\nModel: {args.model}")
    print(f"Mean squared error (MSE): {mse:.2f}")
    print(f"RÂ² score: {r2:.2f}\n")

    # Save the model outputs
    results_df = pd.DataFrame({
        'Actual': y_test,
        'Predicted': y_pred
    })
    results_df.to_csv(os.path.join(args.output_folder, 'prediction_results.csv'), index=False)
    print(f"Prediction results saved to: {os.path.join(args.output_folder, 'prediction_results.csv')}")

    if args.model == 'random_forest':
        # Feature importance
        feature_importances = pd.Series(model.feature_importances_, index=X.columns)
        feature_importances = feature_importances.sort_values(ascending=False)
        print("\nFeature Importances:")
        print(feature_importances)
        
        # Save feature importances
        feature_importances.to_csv(os.path.join(args.output_folder, 'feature_importances.csv'))
        print(f"Feature importances saved to: {os.path.join(args.output_folder, 'feature_importances.csv')}")
    
    elif args.model == 'linear':
        # Extract coefficients and intercept
        coefficients = pd.Series(model.coef_, index=X.columns)
        intercept = model.intercept_
        print("\nRegression Coefficients:")
        print(coefficients)
        print(f"\nIntercept: {intercept:.4f}")
        
        # Save coefficients and intercept
        coefficients.to_csv(os.path.join(args.output_folder, 'regression_coefficients.csv'))
        with open(os.path.join(args.output_folder, 'regression_equation.txt'), 'w') as f:
            equation = f"num_crispr_arrays = {intercept:.4f}"
            for feature, coef in coefficients.items():
                equation += f" + ({coef:.4f} * {feature})"
            f.write(equation)
        
        print(f"Regression coefficients saved to: {os.path.join(args.output_folder, 'regression_coefficients.csv')}")
        print(f"Regression equation saved to: {os.path.join(args.output_folder, 'regression_equation.txt')}")
    
    if args.model == 'linear':
        # Optionally, print the regression equation in a readable format
        print("\nRegression Equation:")
        equation = f"num_crispr_arrays = {intercept:.4f}"
        for feature, coef in coefficients.items():
            equation += f" + ({coef:.4f} * {feature})"
        print(equation)

if __name__ == '__main__':
    main()